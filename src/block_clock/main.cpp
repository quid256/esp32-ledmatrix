#include <Arduino.h>
#include <ESP32-HUB75-MatrixPanel-I2S-DMA.h>
#include "matrix_config.h"

#include <WiFi.h>
#include "secrets.h"

/*
 * Pointers to read-only path data. The contents are:
 *
 *  - binary grids for each digit. Each digit has more than one grid associated with it,
 *    called a "variant". these variants look almost identical, but the ancillary blocks
 *    that don't contribute to digit shape are located in different places.
 *  - step path data. For each relevant (digit/variant, digit+1/target_variant), a
 *    collection of "steps" (i.e. block movements) that'll get you from the former to the
 *    latter. There's more than one "path" for each (source, target), so things will look
 *    more visually random
 *
 * This data can be re-generated by running `node sokoban.js`. This takes kind of a long
 * time -- The code in that file performs an expensive randomized search for a path from
 * each digit/variant to the next digit/variant. The details of how this information is
 * encoded in the file can be found in `sokoban.js`.
 */
extern const uint8_t data_start[] asm("_binary_mockups_out_bin_start");
extern const uint8_t data_end[] asm("_binary_mockups_out_bin_end");

#define MILITARY_TIME false

// Colors that're used in the clock (r, g, b)
#define CLR_ACTIVE 0, 200, 200
#define CLR_SEMIACTIVE 0, 110, 110
#define CLR_INACTIVE 50, 50, 50

// Size of the blocks (in LEDs)
const uint8_t block_size = 3;

// The display object
MatrixPanel_I2S_DMA* display = makePanel(true);

/// Interpolate between two colors
uint16_t interpolate_color(
    double amnt, uint8_t r1, uint8_t g1, uint8_t b1, uint8_t r2, uint8_t g2, uint8_t b2
) {

    return display->color565(
        static_cast<uint8_t>((1 - amnt) * r1 + amnt * r2),
        static_cast<uint8_t>((1 - amnt) * g1 + amnt * g2),
        static_cast<uint8_t>((1 - amnt) * b1 + amnt * b2)
    );
}

/// Get the color associated with a block at (col, row)
uint16_t get_color(double col, double row) {
    double l = max(constrain(abs(row - 5.) - 2., 0., 2.), constrain(col - 2, 0., 1.));

    if (l < 1) {
        return interpolate_color(l, CLR_ACTIVE, CLR_SEMIACTIVE);
    } else if (l < 2) {
        return interpolate_color(l - 1, CLR_SEMIACTIVE, CLR_INACTIVE);
    } else {
        return display->color565(CLR_INACTIVE);
    }
}

// Contains pointers to variant data per-digit
const uint8_t* variants[10];

/**
 * Represents the state of a digit composed of blocks, or a partial interpolation between
 * two such digits.
 */
struct BlockDigit {
  private:
    /**
     * The internal state of the 4x11 grid associated with this digit.
     *
     * The state is encoded as a 6-element array of bytes, where each consecutive pair of
     * 2 rows is encoded in a single byte, i.e.:
     *
     *   0100 } first 4 bits of out[0]
     *   1011 } last 4 bits of out[0]
     *   0100 } first 4 bits of out[1]
     *   ...
     *
     * This is also how states are encoded in the read-only out.bin data. This is
     * convenient because It means loading one of these states just involves doing a
     * memcpy.
     */
    uint8_t out[6];

    /**
     * A pointer to where the step data currently being used is located. Step data encodes
     * the set of block movements that evolve from one digit/variant to another
     * digit/variant
     *
     * Step data has the following format:
     *   step_data[0] = The digit/variant that these steps evolve from
     *   step_data[1] = The digit/variant that these steps evolve to
     *   step_data[2] = The # of steps in the process
     *   step_data[3] .. step_data[step_data[2]-1] = One byte per step
     */
    const uint8_t* step_data;

    /// The current step that this digit is on
    uint8_t step_index;

    /// The progress that has been made in interpolating along the current step (0 to 1)
    double progress;

    /// Helper to toggle the state of the cell at (row, col)
    void toggle(uint8_t row, uint8_t col) {
        uint8_t rowshift = !(row & 1) * 4;
        this->out[row / 2] ^= 1 << (3 + rowshift - col);
    }

  public:
    /// The x, y position to render the digit at
    uint8_t x, y;

    /// The digit + digit variant currently being moved *from*
    uint8_t digit, variant;

    /// The digit + digit variant currently being moved *to*
    uint8_t digit_target, variant_target;

    /// Pointer to the full collection of step data in memory. See above for details.
    const uint8_t* step_data_start;

    /// Constructor
    BlockDigit(uint8_t x, uint8_t y, uint8_t digit, uint8_t variant)
        : x(x), y(y), digit(digit), variant(variant) {}

    /**
     * Prepares the digit to interpolate from the current digit/variant to a randomly
     * selected new one.
     *
     * This function does several things:
     *  1. Sets the contents of the buffer to exactly match the current digit/variant
     *  2. Sets the target digit to be the current digit + 1 (mod 10)
     *  3. Randomly selects a variant of that digit to use
     *  4. Randomly selects from memory a path from the current digit to the target digit
     *  5. Reset step_index + progress
     */
    void init() {
        // (1) Set contents of buffer
        memcpy(this->out, variants[this->digit] + 1 + this->variant * 6, 6);

        // (2, 3) Set target + select random variant
        this->digit_target = (this->digit + 1) % 10;
        this->variant_target = random(variants[this->digit_target][0]);

        // (4) Randomly select a path from digit/variant to digit_target/variant_target
        uint8_t fs_index = (this->digit << 4) + this->variant;
        uint8_t ts_index = (this->digit_target << 4) + this->variant_target;
        uint8_t n_ys = 0;
        const uint8_t* ys[10];
        for (const uint8_t* y = this->step_data_start; y < data_end; y += 3 + y[2]) {
            if (y[0] == fs_index && y[1] == ts_index) {
                ys[n_ys++] = y;
            }
        }
        this->step_data = ys[random(n_ys)];

        // (5) Reset step_index and progress
        this->step_index = 0;
        this->progress = 0;
    }

    /// Increment the current digit/variant and reinitialize
    void next_number() {
        this->digit = this->digit_target;
        this->variant = this->variant_target;
        this->init();
    }

    /// Returns true if all of the steps in the current path have been completed
    bool is_finished() { return this->step_index == this->step_data[2]; }

    /// Gets the current step being executed
    uint8_t get_current_step() { return this->step_data[3 + this->step_index]; }

    /// Evolve the buffer according to the step, or do nothing if is_finished() is true
    void step() {
        if (this->is_finished()) {
            return;
        }

        uint8_t step = this->get_current_step();

        // decode step data
        uint8_t row = (step >> 3);
        uint8_t col = (step >> 1) & 3;
        uint8_t dir = step & 1;
        uint8_t other_row = dir ? row + 1 : row;
        uint8_t other_col = dir ? col : col + 1;

        // TODO verify that only one of (row, col) and (other_row, other_col) are active

        // Toggle the cells associated with this step
        this->toggle(row, col);
        this->toggle(other_row, other_col);

        // Reset progress along current step
        this->step_index++;
        this->progress = 0;
    }

    void set_progress(double p) {
        // TODO validate 0<=p<=1
        this->progress = p;
    }

    /// Print the grid out
    void print(MatrixPanel_I2S_DMA* display) {
        uint8_t step = this->get_current_step();

        // decode step data
        uint8_t row = (step >> 3);
        uint8_t col = (step >> 1) & 3;
        uint8_t dir = step & 1;
        uint8_t other_row = dir ? row + 1 : row;
        uint8_t other_col = dir ? col : col + 1;

        for (size_t y = 0; y < 11; y++) {
            size_t i = y / 2;
            size_t k = y % 2;

            for (uint8_t x = 0; x < 4; x++) {
                // Do some bit math to check whether (x, y) is active right now
                if (this->out[i] & (1 << (7 - 4 * k - x))) {
                    if (this->progress > 0 &&
                        ((row == y && col == x) || (other_row == y && other_col == x))) {
                        // If the current cell is active and the current step involve the
                        // block in the current cell moving, then display the block
                        // partially moved
                        uint8_t interp_x = static_cast<uint8_t>(
                            block_size * ((1 - this->progress) * x +
                                          this->progress * (col + other_col - x)) +
                            0.5
                        );
                        uint8_t interp_y = static_cast<uint8_t>(
                            block_size * ((1 - this->progress) * y +
                                          this->progress * (row + other_row - y)) +
                            0.5
                        );
                        display->fillRect(
                            this->x + interp_x,
                            this->y + interp_y,
                            block_size,
                            block_size,
                            get_color(
                                static_cast<double>(interp_x) / block_size,
                                static_cast<double>(interp_y) / block_size
                            )
                        );
                        continue;
                    }
                    display->fillRect(
                        this->x + block_size * x,
                        this->y + block_size * y,
                        block_size,
                        block_size,
                        get_color(x, y)
                    );
                }
            }
        }
    }
};

// Create 4 digits
BlockDigit digits[4] = {
    BlockDigit(7, 15, random(10), 0),
    BlockDigit(19, 15, random(10), 0),
    BlockDigit(37, 15, random(10), 0),
    BlockDigit(49, 15, random(10), 0),
};

void print_clock() {
    display->clearScreen();
    for (size_t i = 0; i < 4; i++) {
        digits[i].print(display);
    }
    display->fillRect(31, 27, 3, 3, display->color565(CLR_SEMIACTIVE));
    display->fillRect(31, 33, 3, 3, display->color565(CLR_SEMIACTIVE));
    display->flipDMABuffer();
}

void evolve_digits_to(uint8_t targets[4], uint32_t d) {
    // Keep track of whether each digit is at its target
    bool finished[4];
    bool all_finished = true;
    for (size_t i = 0; i < 4; i++) {
        finished[i] = (digits[i].digit == targets[i]);
        all_finished = all_finished && finished[i];
    }

    while (!all_finished) {
        for (size_t k = 0; k < 3; k++) {
            delay(d);
            // update the progress along the current step for each currently unfinished
            // digit
            for (size_t i = 0; i < 4; i++) {
                if (!finished[i]) {
                    digits[i].set_progress((static_cast<double>(k) + 1) / 3.);
                }
            }
            print_clock();
        }

        // Update the buffers of each unfinished digit according to the current step
        for (size_t i = 0; i < 4; i++) {
            if (!finished[i]) {
                digits[i].step();
            }
        }

        // If required, increment the number of unfinished digits
        all_finished = true;
        for (size_t i = 0; i < 4; i++) {
            if (finished[i]) {
                continue;
            }

            if (!digits[i].is_finished()) {
                all_finished = false;
                continue;
            }

            digits[i].next_number();
            if (digits[i].digit == targets[i]) {
                finished[i] = true;
            } else {
                all_finished = false;
            }
        }

        print_clock();
    }
}

const char* hostname = "gumby";
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = -18000;
const int daylightOffset_sec = 3600;

int printTime(uint32_t d) {
    struct tm timeinfo;
    for (size_t i = 0; !getLocalTime(&timeinfo, 15); i++) {
        if (i == 10) {
            return 0;
        }
        Serial.println("Failed to obtain time");
        delay(1000);
    }

    uint8_t hour = timeinfo.tm_hour;
    if (!MILITARY_TIME) {
        hour %= 12;
        if (hour == 0) {
            hour = 12;
        }
    }
    uint8_t min = timeinfo.tm_min;

    uint8_t targets[4] = {
        static_cast<uint8_t>(hour / 10),
        static_cast<uint8_t>(hour % 10),
        static_cast<uint8_t>(min / 10),
        static_cast<uint8_t>(min % 10),
    };
    evolve_digits_to(targets, d);
    getLocalTime(&timeinfo, 15);
    Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
    return timeinfo.tm_sec;
}

void setup() {
    // Activate Serial
    Serial.begin(115200);
    while (!Serial)
        ;

    // Init display
    display->begin();
    display->setBrightness8(15); // 0-255
    display->clearScreen();

    display->clearScreen();
    display->fillRect(10, 10, 10, 10, display->color565(200, 0, 0));
    display->flipDMABuffer();

    // Connect to WiFi
    WiFi.persistent(false);
    WiFi.mode(WIFI_STA);
    WiFi.begin(WIFI_SSID, WIFI_PWD);
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.println("connecting to wifi...");
    }
    Serial.println(WiFi.localIP());
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    display->clearScreen();
    display->fillRect(10, 10, 10, 10, display->color565(0, 200, 0));
    display->flipDMABuffer();

    // Load the variant data in to `variants`
    const uint8_t* step_data = data_start;
    for (size_t i = 0; i < 10; i++) {
        variants[i] = step_data;
        step_data += 1 + (*step_data) * 6;
    }

    // initialize the digit objects
    for (size_t i = 0; i < 4; i++) {
        digits[i].step_data_start = step_data;
        digits[i].init();
    }
    printTime(10);
}

void loop() { delay(60500 - 1000 * printTime(75)); }
